import{computed as e,toValue as t,reactive as a,getCurrentInstance as r,onServerPrefetch as n,ref as o,shallowRef as s,toRef as i,nextTick as c,unref as u}from"vue";import{G as l}from"../_/nitro.mjs";import{isPlainObject as d}from"@vue/shared";import{h as f,e as y,f as p,i as h,g as v}from"./server.mjs";const m={trailing:!0};function debounce(e,t=25,a={}){if(a={...m,...a},!Number.isFinite(t))throw new TypeError("Expected `wait` to be a finite number");let r,n,o,s,i=[];const applyFn=(t,r)=>(o=async function(e,t,a){return await e.apply(t,a)}(e,t,r),o.finally(()=>{if(o=null,a.trailing&&s&&!n){const e=applyFn(t,s);return s=null,e}}),o),debounced=function(...e){return a.trailing&&(s=e),o||new Promise(o=>{const c=!n&&a.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const t=a.leading?r:applyFn(this,e);s=null;for(const e of i)e(t);i=[]},t),c?(r=applyFn(this,e),o(r)):i.push(o)})},_clearTimeout=e=>{e&&(clearTimeout(e),n=null)};return debounced.isPending=()=>!!n,debounced.cancel=()=>{_clearTimeout(n),i=[],s=null},debounced.flush=()=>{if(_clearTimeout(n),!s||o)return;const e=s;return s=null,applyFn(this,e)},debounced}function useAsyncData(...a){const l="string"==typeof a[a.length-1]?a.pop():void 0;(function(e,t){if("string"==typeof e)return!1;if("object"==typeof e&&null!==e)return!1;if("function"==typeof e&&"function"==typeof t)return!1;return!0})(a[0],a[1])&&a.unshift(l);let[d,f,h={}]=a;const m=e(()=>t(d));if("string"!=typeof m.value)throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if("function"!=typeof f)throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const b=y();function createInitialFetch(){const t={cause:"initial",dedupe:h.dedupe};return b._asyncData[m.value]?._init||(t.cachedData=h.getCachedData(m.value,b,{cause:"initial"}),b._asyncData[m.value]=function(t,a,r,n,l){t.payload._errors[a]??=void 0;const d=n.getCachedData!==getDefaultCachedData,f=r,y=n.deep?o:s,p=void 0!==l,h=t.hook("app:data:refresh",async e=>{e&&!e.includes(a)||await m.execute({cause:"refresh:hook"})}),m={data:y(p?l:n.default()),pending:e(()=>"pending"===m.status.value),error:i(t.payload._errors,a),status:s("idle"),execute:(...e)=>{const[r,o]=e,s=r&&void 0===o&&"object"==typeof r?r:{};if(t._asyncDataPromises[a]&&"defer"===(s.dedupe??n.dedupe))return t._asyncDataPromises[a];{const e="cachedData"in s?s.cachedData:n.getCachedData(a,t,{cause:s.cause??"refresh:manual"});if(void 0!==e)return t.payload.data[a]=m.data.value=e,m.error.value=void 0,m.status.value="success",Promise.resolve(e)}m._abortController&&m._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),m._abortController=new AbortController,m.status.value="pending";const i=new AbortController,c=new Promise((e,a)=>{try{const r=s.timeout??n.timeout,o=function(e,t,a){const r=e.filter(e=>!!e);if("number"==typeof a&&a>=0){const e=AbortSignal.timeout?.(a);e&&r.push(e)}if(AbortSignal.any)return AbortSignal.any(r);const n=new AbortController;for(const e of r)if(e.aborted){const t=e.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}return n.signal}const onAbort=()=>{const e=r.find(e=>e.aborted),t=e?.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}};for(const e of r)e.addEventListener?.("abort",onAbort,{once:!0,signal:t});return n.signal}([m._abortController?.signal,s?.signal],i.signal,r);if(o.aborted){const e=o.reason;return void a(e instanceof Error?e:new DOMException(String(e??"Aborted"),"AbortError"))}return o.addEventListener("abort",()=>{const e=o.reason;a(e instanceof Error?e:new DOMException(String(e??"Aborted"),"AbortError"))},{once:!0,signal:i.signal}),Promise.resolve(f(t,{signal:o})).then(e,a)}catch(e){a(e)}}).then(async e=>{let r=e;n.transform&&(r=await n.transform(e)),n.pick&&(r=function(e,t){const a={};for(const r of t)a[r]=e[r];return a}(r,n.pick)),t.payload.data[a]=r,m.data.value=r,m.error.value=void 0,m.status.value="success"}).catch(e=>{t._asyncDataPromises[a]&&t._asyncDataPromises[a]!==c||m._abortController?.signal.aborted||("undefined"!=typeof DOMException&&e instanceof DOMException&&"AbortError"===e.name?m.status.value="idle":(m.error.value=v(e),m.data.value=u(n.default()),m.status.value="error"))}).finally(()=>{i.abort(),delete t._asyncDataPromises[a]});return t._asyncDataPromises[a]=c,t._asyncDataPromises[a]},_execute:debounce((...e)=>m.execute(...e),0,{leading:!0}),_default:n.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{h(),t._asyncData[a]?._init&&(t._asyncData[a]._init=!1),d||c(()=>{t._asyncData[a]?._init||(clearNuxtDataByKey(t,a),m.execute=()=>Promise.resolve())})}};return m}(b,m.value,f,h,t.cachedData)),()=>b._asyncData[m.value].execute(t)}h.server??=!0,h.default??=getDefault,h.getCachedData??=getDefaultCachedData,h.lazy??=!1,h.immediate??=!0,h.deep??=p.deep,h.dedupe??="cancel",h._functionName,b._asyncData[m.value];const D=createInitialFetch();b._asyncData[m.value]._deps++;if(!1!==h.server&&b.payload.serverRendered&&h.immediate){const e=D();r()?n(()=>e):b.hook("app:created",async()=>{await e})}const _={data:writableComputedRef(()=>b._asyncData[m.value]?.data),pending:writableComputedRef(()=>b._asyncData[m.value]?.pending),status:writableComputedRef(()=>b._asyncData[m.value]?.status),error:writableComputedRef(()=>b._asyncData[m.value]?.error),refresh:(...e)=>{if(!b._asyncData[m.value]?._init){return createInitialFetch()()}return b._asyncData[m.value].execute(...e)},execute:(...e)=>_.refresh(...e),clear:()=>{const e=b._asyncData[m.value];if(e?._abortController)try{e._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{e._abortController=void 0}clearNuxtDataByKey(b,m.value)}},g=Promise.resolve(b._asyncDataPromises[m.value]).then(()=>_);return Object.assign(g,_),g}function writableComputedRef(t){return e({get:()=>t()?.value,set(e){const a=t();a&&(a.value=e)}})}function clearNuxtDataByKey(e,t){t in e.payload.data&&(e.payload.data[t]=void 0),t in e.payload._errors&&(e.payload._errors[t]=void 0),e._asyncData[t]&&(e._asyncData[t].data.value=u(e._asyncData[t]._default()),e._asyncData[t].error.value=void 0,e._asyncData[t].status.value="idle"),t in e._asyncDataPromises&&(e._asyncDataPromises[t]=void 0)}const getDefault=()=>{},getDefaultCachedData=(e,t,a)=>t.isHydrating?t.payload.data[e]:"refresh:manual"!==a.cause&&"refresh:hook"!==a.cause?t.static.data[e]:void 0;function useFetch(r,n,o){const[s={},i]="string"==typeof n?[{},n]:[n,o],c=e(()=>t(r)),u=e(()=>t(s.key)||"$f"+l([i,"string"==typeof c.value?c.value:"",...generateOptionSegments(s)]));if(!s.baseURL&&"string"==typeof c.value&&"/"===c.value[0]&&"/"===c.value[1])throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:d,lazy:y,default:p,transform:v,pick:m,watch:b,immediate:D,getCachedData:_,deep:g,dedupe:w,timeout:E,...A}=s,x=a({...f,...A,cache:"boolean"==typeof s.cache?void 0:s.cache}),C={server:d,lazy:y,default:p,transform:v,pick:m,immediate:D,getCachedData:_,deep:g,dedupe:w,timeout:E,watch:!1===b?[]:[...b||[],x]};return useAsyncData(!1===b?u.value:u,(e,{signal:a})=>{let r=s.$fetch||globalThis.$fetch;if(!s.$fetch){"string"==typeof c.value&&"/"===c.value[0]&&(!t(s.baseURL)||"/"===t(s.baseURL)[0])&&(r=h())}return r(c.value,{signal:a,...x})},C)}function generateOptionSegments(e){const r=[t(e.method)?.toUpperCase()||"GET",t(e.baseURL)];for(const a of[e.query||e.params]){const e=t(a);if(!e)continue;const n={};for(const[a,r]of Object.entries(e))n[t(a)]=t(r);r.push(n)}if(e.body){const n=t(e.body);if(n)if(n instanceof ArrayBuffer)r.push(l(Object.fromEntries([...new Uint8Array(n).entries()].map(([e,t])=>[e,t.toString()]))));else if(n instanceof FormData){const e={};for(const t of n.entries()){const[a,r]=t;e[a]=r instanceof File?r.name:r}r.push(l(e))}else if(d(n))r.push(l(a(n)));else try{r.push(l(n))}catch{console.warn("[useFetch] Failed to hash body",n)}else r.push(l(n))}return r}export{useFetch as u};
